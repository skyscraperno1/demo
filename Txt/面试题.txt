1.webpack：
     配置脚手架
2.redux，react-redux有什么区别：
     redux可以将参数一级级往下传，react-redux可以使用类似react的上下文方式进行传值，只需要在根目录引入provider，然后在要用到的值的地方使用connect接收，定义一个mapStateToPros方法把需要的参数映射到当前组件就可以直接调用。（context上下文需要再每一层级都用consumer来传递，react-redux更简单）
3.能不能在vue里面用react-redux：
     可以
4.redux里的东西页面刷新会不会消失：
     会消失，不过可以做一个拷贝就不会消失了，存到storage里面就行
5.BFC：
     块级上下文格式化
     定位流，浮动流，弹性盒，body发生改变都会触发BFC，会发生重叠，可以用来防止字体环绕，独立的容器可以独立渲染不互相干扰
     BFC内部的盒子，会在垂直方向，一个接一个地放置。垂直方向上也会发生边距重叠。
     BFC就是页面上的一个独立容器，容器里面的子元素不会影响到外面的元素，外边的也不会影响里边的。
     BFC的区域不会与float重叠。
     计算BFC的高度时，浮动元素也被计算在内。
6.哪些样式可以继承：
     字体的属性，文本的属性，display可见性，表格，列表之类的属性可以继承
7.react-router：
     react中使用history模式来进行路由跳转
     router有hash模式和history模式。
     vue中使用hash，history需要后端支持
8.webstorage
     localstorage，sessionstorage，cookie
     两个页面交互用local storage和cookie+set interval交换数据
9.css3盒模型：
     盒模型分为标准盒模型，和ie盒模型。在css3里面可以用box-sizing属性设置。标准盒模型包括margin，border，padding和content区域，修改为border-box后会把border和padding，content区域合并计算
10.虚拟dom和真实dom的区别，哪个加载更快：
     虚拟dom不会进行排版和重绘操作
     dom重排重绘效率会很低
     虚拟dom可以局部渲染
11.重排和重绘：
     重排会修改页面组件，一定会发生重绘，重绘是页面样式发生改变时才会产生重绘。重排也叫回流
12.CSS三大特性（三大原则）：
     CSS3大原则：层叠性：样式不冲突，不会重叠，样式冲突的话后面的会覆盖前面的；继承性：可以简化代码，有的样式可以从父元素继承，可以少写；优先级：权重更高的会覆盖权重低的
13.for in和for of的区别：
     for of只能遍历数组内的元素，不包括数组的原型属性和索引，只能取值。for  in遍历数组顺序容易乱，更适合遍历对象，遍历对象的话会遍历所有的key和value。
     但是for  of可以正确响应break、continue和return语句，for  of不能遍历普通对象
14.浏览器时间循环机制（eventloop）：
     浏览器中js事件执行的时候，会挨着顺序执行，如果有异步的就会放到时间栈，等其他执行完了，再从事件栈中按顺序拿出来重新执行
15.比较对象相等：
     先判断俩者是不是对象，再判断长度是否一致，再判断俩个对象的所有key值是否相等相同，最后判断俩个对象的相应的key对应的值是否相同，最后递归判断对象里面的对象是否也相等
16.取消componentWillMount()的原因：
     数据初始化（应该放在constructor）所以不会优先渲染，所以应该放在companyDidMount生命周期内
17.key值发生变化会不会出发生命周期：
     会，react里面的key都是唯一的，key变化的时候会先销毁原组件，重新创建组件，所以会出发生命周期，先触发componentshouldupdate，再触发render
18.受控非受控组件：
     表单组件没有value的话就是非受控组件，不能通过state和props来控制，需要添加ref属性来控制，受控组件有value，发生改变的时候会写入到state里面，还需要绑定一个change事件
19.setstate相关：
     setState是同步执行的，但是state不一定同步更新，多次执行setState，内部会合并 ，进行批量操作（事件合成），会执行生命周期
     setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的
20.高阶组件：
     一个函数，传入一个组件，然后返回一个新的组件，传入的组件会变成他的子组件，把公用的一些部分提出来，把修改的部分以参数的形势传进去
21.封装组件实际应用：
     网页中的layout公共页面
22.纯函数组件：
     react的函数组件，没有this，没有生命周期，通过props传值
23.闭包的应用：
     可以用来代替全局变量，也可以用别的函数去访问一个函数内部的值，节约性能
24.原型链：
     函数才有prototype原型链，object没有
25.数据扁平化：
     把复杂数组中的每个值通过方法递归出来放到一个数组里面
26.call和apply的区别：
     两个都是修改this指向的，并且会立即执行函数，但是两个传参的方式不一样，call传入参数可以挨个传入，apply则接收两个参数，第二个参数必须是一个数组的形式
27.HTML5新增特性：
     语义化标签，video，audio，webstorage，canvas
28.前端优化：
     页面懒加载，提高性能；渲染判断，防止全局更新，节省内存，减少HTTP请求，
29.用antdesign遇到的坑：
     table组件的scroll属性添加的属性是max-height，导致页面不好修改高，内容不够的时候会铺不满
30.判断用户权限：
     登陆的时候获取到了用户信息，在事件处判断用户权限来确定是否调用成功
31.css3新特性：
     线性渐变使用，阴影，动画。animation使用@keyframe设置
32.es6中object新增方法：
     Object.is()它用来比较两个值是否严格相等，与严格比较运算符（ === ）的行为基本一致，是在三等号判断的基础上新增了两个不同之处。
     Object.is()不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
     Object.assign()方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。
     Object.keys()、Object.values()、Object.entries()
33.浏览器解析页面：
     先发送请求，把页面请求回来，解析html节点并创建dom树，然后再构建render树，然后进行布局渲染，最后进行js事件加载
34.promise.all：
     合并发送请求
35.restful接口：
     get请求数据，post新增，put修改数据，delete删除资料
36.new关键字做了什么事情：
     1.创建一个新对象
     2.将新对象的_proto_指向构造函数的prototype对象
     3.将构造函数的作用域赋值给新对象 （也就是this指向新对象）
     4.执行构造函数中的代码（为这个新对象添加属性）
     5.返回新的对象
37.屏幕兼容：
     Px是一个绝对字体大小，em则是基于基数（比如：1.5em）来计算出来的相对字体大小。这个基数是需要乘以当前对象从其父级遗传字体大小。rem是基于根节点（比如html）的字体大小进行计算的。
38.add event listener事件捕获冒泡：
     第三个参数为true，不会冒泡，但是会捕获
     第三个参数为false，不会捕获，但是会冒泡
39.宏任务和微任务：
     宏任务：setinterval，settimeout
     微任务：promise
40.setState生命周期:
     只能在didmount里面设置，其他会出现问题
挂载卸载过程
1.constructor()
2.componentWillMount()
3.componentDidMount()
4.componentWillUnmount ()
更新过程
1. componentWillReceiveProps (nextProps)
2.shouldComponentUpdate(nextProps,nextState)
3.componentWillUpdate (nextProps,nextState)
4.componentDidUpdate(prevProps,prevState)
5.render()
41.输入地址后浏览器做了些什么？
     输入url=》浏览器检测缓存=》如果有直接加载，没有就下一步=》解析域名=》向服务器发起tcp链接，建立三次握手=》握手成功发送http请求=》然后服务器收到请求将数据返回=》浏览器读取数据内容，解析html源码生成dom树=》解析css样式=》最后渲染=》然后再加载js交互
42.useEfect里面的数据会对比几次：（老师说是为了面试而面试的题）
     至少两次，触发生命周期执行，更新时对比一次，更新完会对比是否更新成功，会再对比一次
43.useeffect里面的事件怎么让他只执行一次：
     设置一个变量，在使用过后把变量设置为相反值，之后就可以直接阻断下一次执行
44.MySQL数据库默认端口是多少？
     3306
45.什么叫微前端？
     一种由独立交付的多个前端应用组成整体的架构风格。将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，但是在用户看来仍然是同一个产品
46.react组件中的事件最终会绑定在哪里？
     react组件声明的事件最终都会转换成DOM原生事件
47.内存泄漏和垃圾回收机制？
     对不再用到的内存，没有及时释放，就叫做内存泄漏。
     解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。
48.双飞燕布局和圣杯布局：
     圣杯布局和双飞翼布局基本上是一样的，都是两边固定宽度，中间自适应的三栏布局，其中，中间栏放到文档流前面，保证先行渲染。解决方案大体相同，都是三栏全部float:left浮动，区别在于解决中间栏div的内容不被遮挡上，圣杯布局是中间栏在添加相对定位，并配合left和right属性，效果上表现为三栏是单独分开的（如果可以看到空隙的话），而双飞翼布局是在中间栏的div中嵌套一个div，内容写在嵌套的div里，然后对嵌套的div设置margin-left和margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是100%宽度，只不过中间栏的内容通过margin的值显示在中间。
49.数组的方法有哪些（要求全部回答完），哪些方法使用后会修改原数组
50.css怎样使文本出现省略号
51.如果要让文本中的换行符显示，可以设置什么属性
52.一个页面两个div要铺满整个屏幕，使左边div的宽度固定为100，另一个自适应有哪些方法（回答出来的越多越好）
53.如何用原生实现文件上传（从输入框开始到请求发送完成的代码都叫说一遍）